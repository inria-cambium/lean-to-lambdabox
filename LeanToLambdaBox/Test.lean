import Lean
import LeanToLambdaBox
import LeanToLambdaBox.Printing
/-
This file is for interactive experimentation, with results printed in the infoview.
-/

set_option compiler.enableNew true
-- set_option trace.Compiler.init true
-- set_option trace.Compiler.result true
set_option pp.match false

-- So that the binder names generated by quotation are unmangled by Lean's hygiene system, which makes for nicer printing
-- set_option hygiene false

def testNatCases: Nat -> Bool
| 0 => false
| _+1 => true
#print testNatCases.match_1
#erase testNatCases

mutual
def even: Nat -> Bool
  | 0 => true
  | n+1 => odd n
def odd: Nat -> Bool
  | 0 => false
  | n+1 => even n
end

#print even
#print even._unsafe_rec
-- #print even.match_1

#erase even

def foo : Nat :=
  let bar := unsafe 4
  bar

def f n := if n < 3 then "0, 1 or 2" else "3 or more"
set_option pp.all true
#print f
#print ite
#print dite
#check Nat.rec
def NatRec.{u} {motive : Nat → Sort u} (zero : motive Nat.zero) (succ : (n : Nat) → motive n → motive (Nat.succ n)) (t : Nat): motive t :=
  match t with
  | .zero => zero
  | .succ n => succ n (NatRec zero succ n)

#print NatRec._unsafe_rec
def mycaseson: forall (motive: Nat -> Sort u) (n: Nat) (hzero: motive 0) (hsucc: (forall n, motive (n+1))), motive n :=
  fun motive n hzero hsucc =>
    if h: n = 0 then h ▸ hzero else (by omega: n-1+1 = n) ▸ hsucc (n-1)
#print mycaseson
#print Eq.subst

#print List.replicate

#print foo
#print foo.unsafe_impl_3

axiom printbool: Bool -> Unit
axiom mybool: Bool
-- #erase printbool mybool to "testaxiom.ast"

-- #erase 0 config { extern := .preferAxiom, nat := .machine } to "test/zero.ast"
#erase (0 + 1)
#erase (0 + 1) config { extern := .preferAxiom, nat := .machine }

/-
inductive myfalse: Prop where

-- codegen here is fine because this is a type with no constructors
def elim_myfalse_into_type (mf: myfalse): Nat := nomatch mf
#print elim_myfalse_into_type

-- codegen complains here because this is not one of the hardcoded exceptions
def elim_true_into_type (t: True): Nat := match t with | .intro => 0

def elim_and_into_type (w: True ∧ True): Nat := match w with | .intro .. => 0

def projection (p: Nat × Bool): Bool := p.snd

#print Nat.noConfusionType
def nc_ok n1 n2 := @Nat.noConfusion Unit (.succ n1) (.succ n2)
-- Cannot see which constructor n2 starts with
def nc_fail n1 n2 := @Nat.noConfusion Unit (.succ n1) n2
-/
