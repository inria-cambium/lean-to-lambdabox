import Lean
import LeanToLambdaBox
import LeanToLambdaBox.Printing

/-
This file is for interactive experimentation, with results printed in the infoview.
-/

set_option compiler.enableNew true
-- set_option trace.Compiler.init true
-- set_option trace.Compiler.result true
set_option pp.match false

-- So that the binder names generated by quotation are unmangled by Lean's hygiene system, which makes for nicer printing
-- set_option hygiene false

mutual
def even (n: Nat): Bool := match n with | 0 => true | m+1 => odd m
def odd (n: Nat): Bool := Nat.casesOn n false even
end

#print even
#print even._unsafe_rec
#print even.match_1
def foo : Nat :=
  let bar := unsafe 4
  bar

def f n := if n < 3 then "0, 1 or 2" else "3 or more"
set_option pp.all true
#print f
#print ite

#print List.replicate

#print foo
#print foo.unsafe_impl_3

axiom printbool: Bool -> Unit
axiom mybool: Bool
-- #erase printbool mybool to "testaxiom.ast"

#erase 0 config { extern := .preferAxiom, nat := .machine } to "test/zero.ast"
#erase (0 + 1)
#erase (0 + 1) config { extern := .preferAxiom, nat := .machine }

def f (n: Nat): Unit := match n with | 0 => .unit | m+1 => f m
#print f._unsafe_rec
#erase f._unsafe_rec


/-
inductive myfalse: Prop where

-- codegen here is fine because this is a type with no constructors
def elim_myfalse_into_type (mf: myfalse): Nat := nomatch mf
#print elim_myfalse_into_type

-- codegen complains here because this is not one of the hardcoded exceptions
def elim_true_into_type (t: True): Nat := match t with | .intro => 0

def elim_and_into_type (w: True ∧ True): Nat := match w with | .intro .. => 0

def projection (p: Nat × Bool): Bool := p.snd

#print Nat.noConfusionType
def nc_ok n1 n2 := @Nat.noConfusion Unit (.succ n1) (.succ n2)
-- Cannot see which constructor n2 starts with
def nc_fail n1 n2 := @Nat.noConfusion Unit (.succ n1) n2
-/
