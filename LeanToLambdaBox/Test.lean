import Lean
import LeanToLambdaBox
import LeanToLambdaBox.Printing
/-
This file is for interactive experimentation, with results printed in the infoview.
-/

-- set_option trace.Compiler.init true
-- set_option trace.Compiler.result true
set_option pp.match false

-- So that the binder names generated by quotation are unmangled by Lean's hygiene system, which makes for nicer printing
-- set_option hygiene false

inductive Vec (α : Type) : Nat -> Type where
  | nil : Vec α 0
  | cons n (a: α) (as: Vec α n): Vec α (n+1)

#check Vec.cons

def testNatCases: Nat -> Bool
| 0 => false
| _+1 => true
#print testNatCases.match_1
#erase testNatCases

#check Nat.casesOn
#print HSub
#check HSub.mk
#print OfNat
#print LE

#check Array.set!

mutual
def even: Nat -> Bool
  | 0 => true
  | n+1 => odd n
def odd: Nat -> Bool
  | 0 => false
  | n+1 => even n
end

#print even
#print even._unsafe_rec
-- #print even.match_1

#erase even

set_option pp.proofs true
#check Eq.rec

def foo : Nat :=
  let bar := unsafe 4
  bar

def f n := if n < 3 then "0, 1 or 2" else "3 or more"
set_option pp.all true
#print f
#print ite
#print dite
#check Nat.rec
def NatRec.{u} {motive : Nat → Sort u} (zero : motive Nat.zero) (succ : (n : Nat) → motive n → motive (Nat.succ n)) (t : Nat): motive t :=
  match t with
  | .zero => zero
  | .succ n => succ n (NatRec zero succ n)

#print NatRec._unsafe_rec
def mycaseson: forall (motive: Nat -> Sort u) (n: Nat) (hzero: motive 0) (hsucc: (forall n, motive (n+1))), motive n :=
  fun motive n hzero hsucc =>
    if h: n = 0 then h ▸ hzero else (by omega: n-1+1 = n) ▸ hsucc (n-1)
#print mycaseson
#print Eq.subst

#print List.replicate

#print Fin.add
#print foo
#print foo.unsafe_impl_3

axiom printbool: Bool -> Unit
axiom mybool: Bool
-- #erase printbool mybool to "testaxiom.ast"

-- #erase 0 config { extern := .preferAxiom, nat := .machine } to "test/zero.ast"
#erase (0 + 1)
#erase (0 + 1) config { extern := .preferAxiom, nat := .machine }

#check List.foldr
def myfoldrTR (f: α -> β -> β) (init: β) (l: List α): β := l.reverse.foldl (fun b a => f a b) init

#eval List.foldrTR (Nat.add) 0 [1, 2, 3]

#print Fin.instInhabited
#print Fin.ofNat

def one: Fin 2 := 3
#check (rfl: one = 1)

def ff x :=
  let rec g n := if n = 0 then x else h (n-1), h n := if n = 0 then 3 else g (n-1);
  g x

#print ff
set_option pp.all false
#print ff.g
#print ff.g._unsafe_rec
#print ff.h._unsafe_rec
/-
inductive myfalse: Prop where

-- codegen here is fine because this is a type with no constructors
def elim_myfalse_into_type (mf: myfalse): Nat := nomatch mf
#print elim_myfalse_into_type

-- codegen complains here because this is not one of the hardcoded exceptions
def elim_true_into_type (t: True): Nat := match t with | .intro => 0

def elim_and_into_type (w: True ∧ True): Nat := match w with | .intro .. => 0

def projection (p: Nat × Bool): Bool := p.snd

#print Nat.noConfusionType
def nc_ok n1 n2 := @Nat.noConfusion Unit (.succ n1) (.succ n2)
-- Cannot see which constructor n2 starts with
def nc_fail n1 n2 := @Nat.noConfusion Unit (.succ n1) n2
-/
