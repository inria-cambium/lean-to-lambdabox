LBOX_NO_UNBOX_SWITCH=lambda-box-extraction
LBOX_UNBOX_SWITCH=lbox-unbox
MALFUNCTION_NO_FLAMBDA_SWITCH=malfunction
MALFUNCTION_FLAMBDA_SWITCH=malfunction+flambda

# 0 to make without flambda, 1 to use flambda; default is 1.
FLAMBDA?=1
ifeq ($(FLAMBDA),1)
MALFUNCTION_SWITCH=$(MALFUNCTION_FLAMBDA_SWITCH)
else ifeq ($(FLAMBDA),0)
MALFUNCTION_SWITCH=$(MALFUNCTION_NO_FLAMBDA_SWITCH)
else
$(error Variable FLAMBDA must be either 0 or 1, is $(FLAMBDA))
endif

# 0 to use "regular" axioms, 1 to use inlined axioms; default is 1.
INLINE_AXIOMS?=1
ifeq ($(INLINE_AXIOMS),1)
DECIDABLEML=decidable-inline.ml
EQML=eq-inline.ml
NATML=nat-inline.ml
INTML=int-inline.ml
else ifeq ($(INLINE_AXIOMS),0)
DECIDABLEML=decidable.ml
EQML=eq.ml
NATML=nat.ml
INTML=int.ml
else
$(error Variable INLINE_AXIOMS must be either 0 or 1, is $(INLINE_AXIOMS))
endif

ARRAYML?=SekArray.ml

# 0 to keep all constructor arguments, 1 to remove irrelevant ones; default is 0.
PRUNE_CONSTRUCTORS?=0
ifeq ($(PRUNE_CONSTRUCTORS),1)
DECIDABLEML=decidable-pruned.ml
ERASURE_CONFIG+=remove_irrel_constr_args := true,
else ifeq ($(PRUNE_CONSTRUCTORS),0)
else
$(error Variable PRUNE_CONSTRUCTORS must be either 0 or 1, is $(PRUNE_CONSTRUCTORS))
endif

# 0 to keep values of one-constructor one-field inductive types boxed, 1 to unbox; default is 0.
UNBOX?=0
ifeq ($(UNBOX),1)
LBOX_SWITCH=$(LBOX_UNBOX_SWITCH)
else ifeq ($(UNBOX),0)
LBOX_SWITCH=$(LBOX_NO_UNBOX_SWITCH)
else
$(error Variable UNBOX must be either 0 or 1, is $(UNBOX))
endif

LBOX=opam exec --switch=$(LBOX_SWITCH) -- lbox
MALFUNCTION=opam exec --switch=$(MALFUNCTION_SWITCH) -- malfunction
OCAMLOPT=opam exec --switch=$(MALFUNCTION_SWITCH) -- ocamlfind ocamlopt -package zarith,sek

# Space-separated.
malfunction_build_info:=OCAML_ARGS=$(OCAML_ARGS)\
FLAMBDA=$(FLAMBDA)\
INLINE_AXIOMS=$(INLINE_AXIOMS)\
PRUNE_CONSTRUCTORS=$(PRUNE_CONSTRUCTORS)\
UNBOX=$(UNBOX)\
ERASURE_CONFIG=$(ERASURE_CONFIG)\
LBOX_SWITCH=$(LBOX_SWITCH)\
MALFUNCTION_SWITCH=$(MALFUNCTION_SWITCH)\
MALFUNCTION_ARGS=$(MALFUNCTION_ARGS)\
OCAMLPARAM=$(OCAMLPARAM)\
DECIDABLEML=$(DECIDABLEML)\
EQML=$(EQML)\
NATML=$(NATML)\
INTML=$(INTML)\
ARRAYML=$(ARRAYML)

malfunction_build_id:= $(shell echo "$(malfunction_build_info)" | sha256sum | head -c 8)

build:=build/$(malfunction_build_id)
bin:=bin/$(malfunction_build_id)

FORCE:

bin/%: $(bin)/% $(if $(TARGET),FORCE)
ifdef TARGET
	ln -srf $< $(TARGET)
else
	ln -srf $< $@
endif

$(bin)/%: $(build)/decidable.cmx\
	  $(build)/eq.cmx\
          $(build)/nat.cmx\
          $(build)/int.cmx\
	  $(build)/LeanArray.cmx\
          $(build)/axioms.cmx\
	  $(build)/%.cmx\
          $(build)/%_main.ml | $(bin)
	$(OCAMLOPT) -I $(build) -linkpkg $(OCAML_ARGS) $^ -o $@

define register_test
$(let testname harness rest,$(subst :, ,$(1)),\

# The shell magic capitalizes the first letter of the test name to make a module name.
$(build)/$(testname)_main.ml: $(harness).ml.template | $(build)
	sed "s/{{testmodule}}/$(shell echo $(testname) | sed 's/^./\U&/')/g" $(harness).ml.template > $$@

)
endef

$(foreach testspec,$(shell cat ../TESTS),$(eval $(call register_test,$(testspec))))

default:
	$(error No target specified)

$(build):
	mkdir -p $@
	printf "%s\\n" $(malfunction_build_info) > $(build)/cfg
$(bin):
	mkdir -p $@

$(build)/axioms.mli: axioms.mli | $(build)
	cp $< $@

$(build)/axioms.ml: axioms.ml | $(build)
	cp $< $@

$(build)/decidable.mli: decidable.mli | $(build)
	cp $< $@

$(build)/decidable.ml: $(DECIDABLEML) | $(build)
	cp $< $@

# decidable.cmi handled by generic rule (no prerequisites)

$(build)/decidable.cmx: $(build)/decidable.ml $(build)/decidable.cmi
	$(OCAMLOPT) -I $(build) -c $<

$(build)/eq.mli: eq.mli | $(build)
	cp $< $@

$(build)/eq.ml: $(EQML) | $(build)
	cp $< $@

# eq.cmi handled by generic rule (no prerequisites)

$(build)/eq.cmx: $(build)/eq.ml $(build)/eq.cmi
	$(OCAMLOPT) -I $(build) -c $<

$(build)/LeanArray.mli: LeanArray.mli | $(build)
	cp $< $@

$(build)/LeanArray.ml: $(ARRAYML) | $(build)
	cp $< $@

# LeanArray.cmi handled by generic rule (no prerLeanArrayuisites)

$(build)/LeanArray.cmx: $(build)/LeanArray.ml $(build)/LeanArray.cmi
	$(OCAMLOPT) -I $(build) -c $<

$(build)/nat.mli: nat.mli | $(build)
	cp $< $@

$(build)/nat.ml: $(NATML) | $(build)
	cp $< $@

$(build)/nat.cmi: $(build)/nat.mli $(build)/decidable.cmi
	$(OCAMLOPT) -I $(build) -c $<

$(build)/nat.cmx: $(build)/nat.ml $(build)/nat.cmi $(build)/decidable.cmx
	$(OCAMLOPT) -I $(build) -c $<

$(build)/int.mli: int.mli | $(build)
	cp $< $@

$(build)/int.ml: $(INTML) | $(build)
	cp $< $@

$(build)/int.cmi: $(build)/int.mli $(build)/decidable.cmi
	$(OCAMLOPT) -I $(build) -c $<

$(build)/int.cmx: $(build)/int.ml $(build)/int.cmi $(build)/decidable.cmx
	$(OCAMLOPT) -I $(build) -c $<

$(build)/axioms.cmi: $(build)/axioms.mli $(build)/decidable.cmi $(build)/nat.cmi $(build)/int.cmi $(build)/eq.cmi $(build)/LeanArray.cmi
	$(OCAMLOPT) -I $(build) -c $<

$(build)/axioms.cmx: $(build)/axioms.ml $(build)/axioms.cmi $(build)/nat.cmx $(build)/int.cmx $(build)/eq.cmx
	$(OCAMLOPT) -I $(build) -c $<

$(build)/%.lean: test.lean.template | $(build)
	sed "s/{{testfunction}}/$*/g; s/{{extractiondir}}/$(subst /,\/,$(build))/g; s/{{erasureconfig}}/$(ERASURE_CONFIG)/g" $< > $@

# The .ast file containing Î»box S-expressions and the .mli file containing the signature
# of the exposed main function are generated by elaborating the appropriate .lean file.
# Running `lake build` would not work as lake would do nothing on subsequent runs if the .lean has not changed.
$(build)/%.ast $(build)/%.mli: $(build)/%.lean ../FromLeanCommon.lean ../FromLeanCommon/
	lake lean $<

$(build)/%.mlf: $(build)/%.ast
	$(LBOX) ocaml $< > /dev/null

# Malfunction will silently generate an empty .cmi file if not given an .mli interface, but that won't work for linking later.
$(build)/%.cmi: $(build)/%.mli
	$(OCAMLOPT) -c $<

# Depend on axioms.cmx in order to allow cross-module optimizations (esp. inlining)
$(build)/%.cmx: $(build)/%.mlf $(build)/%.cmi $(build)/axioms.cmx
	cd $(build) && $(MALFUNCTION) cmx $(MALFUNCTION_ARGS) $*.mlf

clean:
	rm -rf build bin

.PHONY: Makefile clean

# Don't consider anything as an intermediate file.
.NOTINTERMEDIATE:
