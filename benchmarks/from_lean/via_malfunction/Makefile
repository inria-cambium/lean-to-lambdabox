BUILD_DIR=build
BIN_DIR=bin

default:
	@echo "No target specified, exiting."

$(BUILD_DIR):
	mkdir -p $@
$(BIN_DIR):
	mkdir -p $@

$(BUILD_DIR)/%.lean: test.lean.template | $(BUILD_DIR)
	sed "s/{{testfunction}}/$*/g; s/{{extractiondir}}/$(BUILD_DIR)/g" test.lean.template > $@

# The .ast file containing Î»box S-expressions is generated by elaborating the appropriate .lean file.
# Running `lake build` would not work as lake would do nothing on subsequent runs if the .lean has not changed.
$(BUILD_DIR)/%.ast: $(BUILD_DIR)/%.lean ../FromLeanCommon.lean
	lake lean $<

$(BUILD_DIR)/%.mlf: $(BUILD_DIR)/%.ast
	lbox ocaml $< > /dev/null

# Copying this over so its place in the Git repo is outside of the extraction directory.
$(BUILD_DIR)/%.mli: %.mli | $(BUILD_DIR)
	cp $< $@

# Malfunction will generate an empty .cmi file if not given one, but that won't work for linking later.
$(BUILD_DIR)/%.cmi: $(BUILD_DIR)/%.mli
	ocamlopt.opt $<

$(BUILD_DIR)/%.cmx: $(BUILD_DIR)/%.mlf $(BUILD_DIR)/%.cmi
	cd $(BUILD_DIR) && malfunction cmx $*.mlf

# The shell magic capitalizes the first letter of the test name to make a module name.
$(BIN_DIR)/%_runonce: $(BUILD_DIR)/%.cmx $(BUILD_DIR)/%.cmi runonce.ml.template | $(BIN_DIR)
	sed "s/{{testfunction}}/$*/g; s/{{testmodule}}/$(shell echo $* | sed 's/^./\U&/')/g" runonce.ml.template > $(BUILD_DIR)/$*_runonce.ml
	ocamlopt.opt -I $(BUILD_DIR) $(BUILD_DIR)/$*.cmx $(BUILD_DIR)/$*_runonce.ml -o $@

$(BIN_DIR)/%_repeat: $(BUILD_DIR)/%.cmx $(BUILD_DIR)/%.cmi repeat.ml.template | $(BIN_DIR)
	sed "s/{{testfunction}}/$*/g; s/{{testmodule}}/$(shell echo $* | sed 's/^./\U&/')/g" repeat.ml.template > $(BUILD_DIR)/$*_repeat.ml
	ocamlopt.opt -I $(BUILD_DIR) $(BUILD_DIR)/$*.cmx $(BUILD_DIR)/$*_repeat.ml -o $@
clean:
	rm -rf $(BUILD_DIR) $(BIN_DIR)

.PHONY: all clean

# Don't delete intermediate files
.SECONDARY:
